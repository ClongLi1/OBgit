/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

'use strict';

var obsidian = require('obsidian');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

// SOURCE https://stackoverflow.com/questions/36721830/convert-hsl-to-rgb-and-hex
function hslToHex(h, s, l) {
    l /= 100;
    const a = (s * Math.min(l, 1 - l)) / 100;
    const f = (n) => {
        const k = (n + h / 30) % 12;
        const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
        return Math.round(255 * color)
            .toString(16)
            .padStart(2, "0"); // convert to Hex and prefix "0" if needed
    };
    return `#${f(0)}${f(8)}${f(4)}`;
}
// SOURCE https://stackoverflow.com/questions/46432335/hex-to-hsl-convert-javascript
function hexToHSL(hex) {
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    var r = parseInt(result[1], 16);
    var g = parseInt(result[2], 16);
    var b = parseInt(result[3], 16);
    (r /= 255), (g /= 255), (b /= 255);
    var max = Math.max(r, g, b), min = Math.min(r, g, b);
    var h, s, l = (max + min) / 2;
    if (max == min) {
        h = s = 0; // achromatic
    }
    else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
            case g:
                h = (b - r) / d + 2;
                break;
            case b:
                h = (r - g) / d + 4;
                break;
        }
        h /= 6;
    }
    s = s * 100;
    s = Math.round(s);
    l = l * 100;
    l = Math.round(l);
    h = Math.round(360 * h);
    return [h, s, l];
}
// SOURCE https://gist.github.com/borismus/1032746
function convertDataURIToBinary(dataURI) {
    const base64Index = dataURI.indexOf(";base64,") + ";base64,".length;
    const base64 = dataURI.substring(base64Index);
    const raw = window.atob(base64);
    const rawLength = raw.length;
    let array = new Uint8Array(new ArrayBuffer(rawLength));
    for (let i = 0; i < rawLength; i++) {
        array[i] = raw.charCodeAt(i);
    }
    return array;
}
function sumRows(array) {
    const result = [];
    array.forEach((row, i) => {
        row.reduce((a, b) => (result[i] = a + b));
    });
    return result;
}
function normalise(array) {
    const max = Math.max(...array);
    return array.map((x) => x / max);
}

// !SECTION Matrix Modal
// SECTION SettingsTab
class AdjacencyMatrixMakerSettingTab extends obsidian.PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        // this.plugin = plugin;
    }
    display() {
        let { containerEl } = this;
        containerEl.empty();
        containerEl.createEl("h2", {
            text: "Settings for Adjacency Matrix Maker",
        });
        // SECTION Custom settings
        const coloursDiv = containerEl.createDiv();
        // Main colour picker
        const mainColourDiv = coloursDiv.createDiv();
        mainColourDiv.createEl("h4", {
            text: "Main colour",
        });
        const mainColourPicker = mainColourDiv.createEl("input", { type: "color" });
        mainColourPicker.value = hslToHex(...this.plugin.settings.mainColourComponents);
        mainColourPicker.addEventListener("change", () => __awaiter(this, void 0, void 0, function* () {
            this.plugin.settings.mainColourComponents = hexToHSL(mainColourPicker.value);
            yield this.plugin.saveSettings();
        }));
        // Background colour picker
        const backgroundColourDiv = coloursDiv.createDiv();
        backgroundColourDiv.createEl("h4", {
            text: "Background colour",
        });
        const backgroundColourPicker = backgroundColourDiv.createEl("input", {
            type: "color",
        });
        backgroundColourPicker.value = this.plugin.settings.backgroundColour;
        backgroundColourPicker.addEventListener("change", () => __awaiter(this, void 0, void 0, function* () {
            this.plugin.settings.backgroundColour = backgroundColourPicker.value;
            yield this.plugin.saveSettings();
        }));
        // // Folder squares colour picker
        // const folderSquaresColourDiv = coloursDiv.createDiv();
        // folderSquaresColourDiv.createEl("h4", {
        //   text: "Folder squares colour",
        // });
        // const folderSquaresColourPicker = folderSquaresColourDiv.createEl("input", {
        //   type: "color",
        // });
        // folderSquaresColourPicker.value = this.plugin.settings.folderSquaresColour;
        // folderSquaresColourPicker.addEventListener("change", async () => {
        //   this.plugin.settings.folderSquaresColour =
        //     folderSquaresColourPicker.value;
        //   await this.plugin.saveSettings();
        // });
        // !SECTION Custom settings
        // SECTION Obsidian Settings
        new obsidian.Setting(containerEl)
            .setName("Show folders")
            .setDesc("Add squares to the image showing which folder a note is in")
            .addToggle((toggle) => toggle
            .setValue(this.plugin.settings.showFolders)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            this.plugin.settings.showFolders = value;
            yield this.plugin.saveSettings();
        })));
        const initialScale = this.plugin.settings.userScale === 0
            ? ""
            : this.plugin.settings.userScale;
        new obsidian.Setting(containerEl)
            .setName("Image Scale")
            .setDesc("The side length in pixels of each cell in the matrix. A larger scale will make for longer loading times, but a crisper image. The default value is determined by the number of files in your vault (More files = higher scale value). Leave blank to use the default.")
            .addText((text) => text
            .setPlaceholder("Scale")
            .setValue(initialScale.toString())
            .onChange((newValue) => __awaiter(this, void 0, void 0, function* () {
            const newScale = Number(newValue);
            if (!(Number.isInteger(newScale) && newScale >= 0)) {
                new obsidian.Notice("Scale must be an integer greater than or equal to 1");
                return;
            }
            this.plugin.settings.userScale = newScale;
            yield this.plugin.saveSettings();
            //   console.log(this.plugin.settings.userScale)
        })));
        new obsidian.Setting(containerEl)
            .setName("Image name")
            .setDesc("The value used to name a saved image. The name will have the datetime appended automatically")
            .addText((text) => text
            .setPlaceholder("Default name")
            .setValue(this.plugin.settings.imgName)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            this.plugin.settings.imgName = value;
            yield this.plugin.saveSettings();
        })));
        new obsidian.Setting(containerEl)
            .setName("Folder path")
            .setDesc('The folder to save the image in. The default is the root of your vault \'/\'. If you do change it, leave out the first slash in front. e.g. To save the image in "Attachments", type in "Attachments" (no quotes)')
            .addText((text) => text
            .setPlaceholder("/")
            .setValue(this.plugin.settings.folderPath)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            this.plugin.settings.folderPath = value;
            yield this.plugin.saveSettings();
        })));
        // !SECTION Obsidian Settings
    }
}

const DEFAULT_SETTINGS = {
    mainColourComponents: [202, 72, 44],
    backgroundColour: "#141414",
    userScale: 0,
    imgName: "adj",
    folderPath: "/",
    showFolders: true,
};
function validFolderPathQ(path) {
    const file = app.vault.getAbstractFileByPath(path);
    return file && file instanceof obsidian.TFolder;
}
function cutAtDepth(paths, depth) {
    const splitPaths = paths.map((path) => path.split("/").slice(1, -1));
    const cutPaths = [];
    splitPaths.forEach((path, i) => {
        if (path.length >= depth) {
            cutPaths.push({
                file: i,
                cutPath: path.slice(0, depth).join("/"),
            });
        }
    });
    return cutPaths;
}
function squaresAtN(cutPaths, depth) {
    const squares = [];
    let start = cutPaths[0].file;
    for (let i = 1; i < cutPaths.length - 1; i++) {
        const prev = cutPaths[i - 1].cutPath;
        const curr = cutPaths[i].cutPath;
        const next = cutPaths[i + 1].cutPath;
        if (prev !== curr) {
            start = cutPaths[i].file;
        }
        if (curr !== next) {
            squares.push({ depth, start, end: cutPaths[i].file });
        }
    }
    // Last square
    const lastSquarePath = cutPaths.last().cutPath;
    // NOTE Return the file number of the first cutPath whose path matches the lastSquarePath
    const lastSquareStart = cutPaths.filter((path) => {
        if (path.cutPath === lastSquarePath) {
            return true;
        }
        else {
            return false;
        }
    })[0].file;
    squares.push({ depth, start: lastSquareStart, end: cutPaths.last().file });
    return squares;
}
function allSquares(files) {
    const paths = files.map((file) => file.path);
    // This drops the filename.md at the end, and accounts for files in root of vault, changes them to '/'
    const fullFolders = paths.map((path) => path.match(/(.+)\//) ? "/" + path.match(/(.+)\//)[1] + "/" : "/");
    const maxDepth = Math.max(...fullFolders.map((path) => path.split("/").length - 2));
    const allSquaresArr = [];
    for (let i = 1; i <= maxDepth; i++) {
        allSquaresArr.push(squaresAtN(cutAtDepth(fullFolders, i), i));
    }
    return allSquaresArr;
}
// !SECTION Squares
function drawAdjAsImage(scale, alphas, adjArray, canvas, settings, files) {
    return __awaiter(this, void 0, void 0, function* () {
        const ctx = canvas.getContext("2d");
        const size = alphas.length;
        canvas.width = size * scale;
        canvas.height = canvas.height;
        const mnComp = settings.mainColourComponents;
        const bgColour = settings.backgroundColour;
        for (let i = 0; i < size; i++) {
            // Where the alpha of that row is proportional to the number of coloured cells in that row
            /// Make the more "popular" notes pop
            const alpha = alphas[i] / 3 + 0.66666666666;
            for (let j = 0; j < size; j++) {
                // Position of the top-left corner of the next pixel
                const x = i * scale;
                const y = j * scale;
                let cellColour;
                // Change colour if the two notes are linked
                if (adjArray[i][j] === 0) {
                    cellColour = bgColour;
                }
                else {
                    cellColour = `hsla(${mnComp[0]}, ${mnComp[1]}%, ${mnComp[2]}%, ${alpha})`;
                }
                // Draw the cell
                ctx.beginPath();
                ctx.fillStyle = cellColour;
                ctx.fillRect(x, y, scale, scale);
            }
        }
        if (settings.showFolders) {
            const squareArrs = allSquares(files);
            console.log(squareArrs);
            squareArrs.forEach((squareArr) => {
                if (squareArr[0]) {
                    switch (squareArr[0].depth) {
                        case 1:
                            ctx.strokeStyle = "#FF0000FF";
                            break;
                        case 2:
                            ctx.strokeStyle = "#FF6700FF";
                            break;
                        case 3:
                            ctx.strokeStyle = "#FFFF00FF";
                            break;
                        case 4:
                            ctx.strokeStyle = "#00FF00FF";
                            break;
                        case 5:
                            ctx.strokeStyle = "#0000FFFF";
                            break;
                        case 6:
                            ctx.strokeStyle = "#00FFFFFF";
                            break;
                        case 7:
                            ctx.strokeStyle = "#FF00FFFF";
                            break;
                        default:
                            ctx.strokeStyle = "white";
                            break;
                    }
                    squareArr.forEach((square) => {
                        const start = square.start * scale;
                        const sideLength = (square.end - square.start + 1) * scale;
                        ctx.strokeRect(start, start, sideLength, sideLength);
                    });
                }
            });
        }
        const img = new Image();
        img.src = canvas.toDataURL("image/svg");
        return img;
    });
}
class AdjacencyMatrixMakerPlugin extends obsidian.Plugin {
    constructor() {
        super(...arguments);
        this.makeAdjacencyMatrix = () => __awaiter(this, void 0, void 0, function* () {
            const files = this.app.vault.getMarkdownFiles();
            const size = files.length;
            // TODO: should just be able to slot in a check for settings.userScale ? settings.userScale
            const scale = Number.isInteger(this.settings.userScale) && Number(this.settings.userScale) >= 1
                ? Number(this.settings.userScale)
                : size < 50
                    ? 16
                    : size < 100
                        ? 8
                        : size < 200
                            ? 4
                            : 2;
            // Canvas setup
            const canvas = document.createElement("canvas");
            canvas.width = size * scale;
            canvas.height = size * scale;
            const adjArray = this.populateAdjacencyMatrixArr(files);
            const alphas = normalise(sumRows(adjArray));
            const img = yield drawAdjAsImage(scale, alphas, adjArray, canvas, this.settings, files);
            new MatrixModal(this.app, img, files, scale, adjArray, this.settings).open();
        });
    }
    onload() {
        return __awaiter(this, void 0, void 0, function* () {
            console.log("Loading Adjacency Matrix Maker plugin");
            yield this.loadSettings();
            obsidian.addIcon("matrix", `<path fill="currentColor" stroke="currentColor" d="M8,8v84h84v-6H80V74h-6V62h6v-6H68V44H38V32h6v-6h12v6h-6v6h12v-6h18V20h12v-6h-6V8h-6v6h-6V8h-6v6h-6V8h-6v12h-6V8h-6v12 h-6v6h-6v12H20v6h12v6h-6v6h12v-6h24v24h6v6h6v6H62V74h-6v6H44v6h-6v-6H26v6H14V38h6V20h-6V8L8,8z M20,20h6V8h-6V20z M56,74v-6h-6 v6H56z M26,56h-6v6h6V56z M68,44h6v6h6v6h12v-6h-6v-6h6v-6H68L68,44z M80,62v12h6v-6h6v-6H80z M86,74v6h6v-6H86z M32,8v6h6V8L32,8 z M62,20h6v6h-6V20z M86,26v6h6v-6H86z M50,56v6h6v-6H50z M38,62v6h-6v6h12V62H38z M20,68v6h6v-6H20z"/>`);
            this.addRibbonIcon("matrix", "Adjacency Matrix", this.makeAdjacencyMatrix);
            this.addCommand({
                id: "adjacency-matrix",
                name: "Open Adjacency Matrix",
                callback: this.makeAdjacencyMatrix,
            });
            this.addSettingTab(new AdjacencyMatrixMakerSettingTab(this.app, this));
        });
    }
    // Does `from` have a link going to `to`?
    linkedQ(from, to) {
        var _a;
        return (_a = this.app.metadataCache.resolvedLinks[from.path]) === null || _a === void 0 ? void 0 : _a.hasOwnProperty(to.path);
    }
    populateAdjacencyMatrixArr(files) {
        const size = files.length;
        const adjArray = [];
        for (let i = 0; i < size; i++) {
            adjArray.push([]);
            for (let j = 0; j < size; j++) {
                // 1 or 0 so that sumRows works (instead of true or false)
                /// Todo: I think I can just use the link count here, nothing else to do
                adjArray[i][j] = this.linkedQ(files[i], files[j]) ? 1 : 0;
            }
        }
        return adjArray;
    }
    onunload() {
        console.log("unloading adjacency matrix maker plugin");
    }
    loadSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
        });
    }
    saveSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.saveData(this.settings);
        });
    }
}
// SECTION Matrix Modal
class MatrixModal extends obsidian.Modal {
    constructor(app, img, files, scale, adjArray, settings) {
        super(app);
        this.img = img;
        this.files = files;
        this.scale = scale;
        this.adjArray = adjArray;
        this.settings = settings;
    }
    onOpen() {
        const modal = this;
        const app = this.app;
        const img = this.img;
        const scale = this.scale;
        const files = this.files;
        const adjArray = this.adjArray;
        const settings = this.settings;
        // ANCHOR Setup Modal layout
        let { contentEl } = this;
        const parentEl = contentEl.parentElement;
        parentEl.style.alignItems = 'stretch';
        parentEl.style.margin = '50px';
        contentEl.style.width = `${Math.round(screen.width / 1.5)}px`;
        contentEl.style.height = `${Math.round(screen.height / 1.3)}px`;
        const vaultName = app.vault.getName();
        contentEl.createEl("h2", { text: `Adjacency matrix of: ${vaultName}` });
        const buttonRow = contentEl.createDiv({ cls: "matrixModalButtons" });
        const canvas = contentEl.createEl("canvas");
        canvas.width = Math.round(screen.width / 1.5);
        canvas.height = Math.round(screen.height / 1.3);
        const ctx = canvas.getContext("2d");
        // Save image button
        const saveImageButton = buttonRow.createEl("button", {
            text: "Save Image",
        });
        const resetScaleButton = buttonRow.createEl("button", {
            text: "Reset Scale",
        });
        // Tooltip
        const tooltip = contentEl.createDiv({ cls: "adj-tooltip" });
        const tooltipText = tooltip.createSpan({ cls: "adj-tooltip-text" });
        // SECTION Zoom & Pan code
        // SOURCE https://stackoverflow.com/questions/33925012/how-to-pan-the-canvas
        // ANCHOR `mouse`
        const mouse = {
            x: 0,
            y: 0,
            w: 0,
            alt: false,
            shift: false,
            ctrl: false,
            buttonLastRaw: 0,
            buttonRaw: 0,
            over: false,
            buttons: [1, 2, 4, 6, 5, 3],
            rx: 0,
            ry: 0,
            oldX: 0,
            oldY: 0,
        };
        function mouseMove(event) {
            mouse.x = event.offsetX;
            mouse.y = event.offsetY;
            // mouse.alt = event.altKey;
            // mouse.shift = event.shiftKey;
            mouse.ctrl = event.ctrlKey;
            if (event.type === "mousedown") {
                event.preventDefault();
                mouse.buttonRaw |= mouse.buttons[event.which - 1];
            }
            else if (event.type === "mouseup") {
                mouse.buttonRaw &= mouse.buttons[event.which + 2];
            }
            else if (event.type === "mouseout") {
                mouse.buttonRaw = 0;
                mouse.over = false;
            }
            else if (event.type === "mouseover") {
                mouse.over = true;
            }
            else if (event.type === "mousewheel") {
                event.preventDefault();
                mouse.w = -event.deltaY;
            }
        }
        function setupMouse(e) {
            e.addEventListener("mousemove", mouseMove);
            e.addEventListener("mousedown", mouseMove);
            e.addEventListener("mouseup", mouseMove);
            e.addEventListener("mouseout", mouseMove);
            e.addEventListener("mouseover", mouseMove);
            e.addEventListener("mousewheel", mouseMove);
            e.addEventListener("contextmenu", function (e) {
                e.preventDefault();
            }, false);
        }
        setupMouse(canvas);
        const initialScale = Math.min(1 / (img.width / contentEl.clientWidth), 1 / (img.height / contentEl.clientHeight));
        // ANCHOR `displayTransform`
        // Real space, real, r (prefix) refers to the transformed canvas space.
        // c (prefix), chase is the value that chases a requiered value
        var displayTransform = {
            x: 0,
            y: 0,
            ox: 0,
            oy: 0,
            scale: initialScale,
            rotate: 0,
            cx: 0,
            cy: 0,
            cox: 0,
            coy: 0,
            cscale: 1,
            crotate: 0,
            dx: 0,
            dy: 0,
            dox: 0,
            doy: 0,
            dscale: 1,
            drotate: 0,
            drag: 0.2,
            accel: 0.9,
            matrix: [0, 0, 0, 0, 0, 0],
            invMatrix: [0, 0, 0, 0, 0, 0],
            mouseX: 0,
            mouseY: 0,
            ctx: ctx,
            setTransform: function () {
                let m = this.matrix;
                let i = 0;
                this.ctx.setTransform(m[i++], m[i++], m[i++], m[i++], m[i++], m[i++]);
            },
            setHome: function () {
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            },
            updateValues: function () {
                // smooth all movement out. drag and accel control how this moves
                /// acceleration
                this.dx += (this.x - this.cx) * this.accel;
                this.dy += (this.y - this.cy) * this.accel;
                this.dox += (this.ox - this.cox) * this.accel;
                this.doy += (this.oy - this.coy) * this.accel;
                this.dscale += (this.scale - this.cscale) * this.accel;
                // this.drotate += (this.rotate - this.crotate) * this.accel;
                /// drag
                this.dx *= this.drag;
                this.dy *= this.drag;
                this.dox *= this.drag;
                this.doy *= this.drag;
                this.dscale *= this.drag;
                // this.drotate *= this.drag;
                /// set the chase values. Chase chases the requiered values
                this.cx += this.dx;
                this.cy += this.dy;
                this.cox += this.dox;
                this.coy += this.doy;
                this.cscale += this.dscale;
                // this.crotate += this.drotate;
                /// create the display matrix
                this.matrix[0] = this.cscale;
                /// I don't use crotate, so these values will always be 0
                // this.matrix[1] = Math.sin(this.crotate) * this.cscale;
                // this.matrix[2] = -this.matrix[1];
                this.matrix[3] = this.matrix[0];
                /// set the coords relative to the origin
                this.matrix[4] = -(this.cx * this.matrix[0]) + this.cox;
                this.matrix[5] = -(this.cy * this.matrix[3]) + this.coy;
                /// create invers matrix
                let det = this.matrix[0] * this.matrix[3];
                this.invMatrix[0] = this.matrix[3] / det;
                // this.invMatrix[1] = -this.matrix[1] / det;
                // this.invMatrix[2] = -this.matrix[2] / det;
                this.invMatrix[3] = this.matrix[0] / det;
                /// check for mouse. Do controls and get real position of mouse.
                if (mouse !== undefined) {
                    // if there is a mouse get the real cavas coordinates of the mouse
                    if (mouse.oldX !== undefined && (mouse.buttonRaw & 1) === 1) {
                        // check if panning (middle button)
                        var mdx = mouse.x - mouse.oldX; // get the mouse movement
                        var mdy = mouse.y - mouse.oldY;
                        // get the movement in real space
                        var mrx = mdx * this.invMatrix[0]; // + mdy * this.invMatrix[2];
                        var mry = mdy * this.invMatrix[3]; // + mdx * this.invMatrix[1]
                        this.x -= mrx;
                        this.y -= mry;
                    }
                    // do the zoom with mouse wheel
                    if (mouse.w !== undefined && mouse.w !== 0) {
                        this.ox = mouse.x;
                        this.oy = mouse.y;
                        this.x = this.mouseX;
                        this.y = this.mouseY;
                        /* Special note from answer */
                        // comment out the following is you change drag and accel
                        // and the zoom does not feel right (lagging and not
                        // zooming around the mouse
                        /*
                        this.cox = mouse.x;
                        this.coy = mouse.y;
                        this.cx = this.mouseX;
                        this.cy = this.mouseY;
                        */
                        if (mouse.w > 0) {
                            // zoom in
                            this.scale *= 1.15;
                            mouse.w -= 20;
                            if (mouse.w < 0) {
                                mouse.w = 0;
                            }
                        }
                        if (mouse.w < 0) {
                            // zoom out
                            this.scale *= 1 / 1.15;
                            mouse.w += 20;
                            if (mouse.w > 0) {
                                mouse.w = 0;
                            }
                        }
                    }
                    // get the real mouse position
                    var screenX = mouse.x - this.cox;
                    var screenY = mouse.y - this.coy;
                    this.mouseX = this.cx + screenX * this.invMatrix[0]; // + screenY * this.invMatrix[2]
                    this.mouseY = this.cy + screenY * this.invMatrix[3]; //screenX * this.invMatrix[1] +
                    mouse.rx = this.mouseX; // add the coordinates to the mouse. r is for real
                    mouse.ry = this.mouseY;
                    // save old mouse position
                    mouse.oldX = mouse.x;
                    mouse.oldY = mouse.y;
                }
            },
        };
        function update() {
            // update the transform
            displayTransform.updateValues();
            // set home transform to clear the screem
            displayTransform.setHome();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            displayTransform.setTransform();
            ctx.drawImage(img, 0, 0);
            if (mouse.buttonRaw === 4) {
                // right click to return to home
                displayTransform.scale = initialScale;
            }
        }
        // update();
        this.interval = setInterval(update, 25);
        // !SECTION Zoom & Pan code
        // ANCHOR Tooltip
        function handleTooltip(e) {
            const x = e.offsetX;
            const y = e.offsetY;
            // Todo check that the mouse is inside the canvas first
            const realx = mouse.rx;
            const realy = mouse.ry;
            if (realx >= 0) {
                // Convert coord to cell number
                const i = Math.round(realx / scale - 0.5);
                const j = Math.round(realy / scale - 0.5);
                // Pick the two files that cell refers to
                const fileI = files[i];
                const fileJ = files[j];
                // If hovering over linked notes, show tooltip, and move it there
                if (adjArray[i][j] === 1 || mouse.ctrl) {
                    document.body.style.cursor = "pointer";
                    tooltip.addClass("show");
                    tooltip.style.transform = `translate(${x + 15}px, ${y - canvas.height - 80}px)`;
                    tooltipText.innerText = `${fileI.basename} → ${fileJ.basename}`;
                }
                else {
                    document.body.style.cursor = "initial";
                    // Hide the tooltip
                    tooltip.removeClass("show");
                }
            }
        }
        canvas.addEventListener("mousemove", obsidian.debounce(handleTooltip, 25, true));
        // ANCHOR OpenClickedCellAsFile
        function openClickedCellAsFile() {
            return __awaiter(this, void 0, void 0, function* () {
                const realx = mouse.rx;
                const realy = mouse.ry;
                // Convert coord to cell number
                const i = Math.round(realx / scale - 0.5);
                const j = Math.round(realy / scale - 0.5);
                // Pick the file that cell refers to (the `from` value)
                const fileI = files[i];
                if (adjArray[i][j] === 1) {
                    // Open the clicked cell (from, not to) in the active leaf
                    yield app.workspace.activeLeaf.openFile(fileI);
                    modal.close();
                }
            });
        }
        canvas.addEventListener("click", openClickedCellAsFile);
        resetScaleButton.addEventListener("click", () => {
            displayTransform.scale = initialScale;
        });
        // ANCHOR saveCanvasAsImage
        function saveCanvasAsImage() {
            const arrBuff = convertDataURIToBinary(img.src);
            // Add the current datetime to the image name
            /// TODO Allow customisable datetime format
            const now = window.moment().format("YYYY-MM-DD HHmmss");
            // Image name from settings
            const imgName = settings.imgName;
            // Folder path to save img
            const folderPath = settings.folderPath === "" ? "/" : settings.folderPath;
            if (validFolderPathQ(folderPath)) {
                app.vault.createBinary(`${folderPath}/${imgName} ${now}.png`, arrBuff);
                new obsidian.Notice("Image saved");
            }
            else {
                new obsidian.Notice("Chosen folder path does not exist in your vault");
            }
        }
        saveImageButton.addEventListener("click", saveCanvasAsImage);
    }
    onClose() {
        let { contentEl } = this;
        clearInterval(this.interval);
        contentEl.empty();
    }
}

module.exports = AdjacencyMatrixMakerPlugin;


/* nosourcemap */